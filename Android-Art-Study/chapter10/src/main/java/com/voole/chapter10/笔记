Android的消息机制

        Handler的使用过程很简单，通过它可以轻松的将一个任务切换到handler所在的线程中去执行。很多人认为handler的
        作用就是更新UI，这的确没错，但是更新UI只是handler的一个特殊的场景。

        MessageQueue虽然叫消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息队列。

        由于MessageQueue只是一个消息存储的单元，它不能去处理消息，而Looper就填补了这个功能，Looper会以无限循环
        的形式去查找是否有新的消息，如果有的话就处理消息，否则就一直等待着。

        Looper中还有一个重要的概念，那就是ThreadLocal，ThreadLocal并不是线程，他的作用是可以在每一个线程中
        存储数据，我们知道，Handler创建的时候会采用当前线程的looper来构造消息循环系统，那么handler内部如何获取
        到当前线程的Looper呢？这就要使用ThreadLocal了，ThreadLocal可以在不同的线程中互不干扰的存储并提供数据，
        通过ThreadLocal可以轻松的获取到每个线程的looper。当然需要注意的是，线程默认是没有looper的，如果需要使用handler
        ，就必须为线程创建looper。

        系统为什么不允许在子线程中访问UI呢？这是因为Android的UI控件不是线程安全的，如果多线程中并发访问可能会导致
        UI控件处于不可预期的状态。那为什么系统不对UI控件加上锁机制呢?缺点有两个：首先加上锁机制会让UI访问的逻辑
        变的复杂，其次加锁会降低UI访问的效率。

        注意looper是运行在handler所在的线程中的。这样一来，handler中的业务逻辑就被切换到创建handler所在的线程
        中去执行了。

        ThreadLocal的工作原理：
            ThreadLocal是一个线程内部的数据存储类，通过他可以在指定的线程中存储数据，数据存储后，只有在指定线程
         中获取到存储的数据，对于其他线程来说则无法获取到数据。
            一般来说，当某些数据是以线程为作用域，并且不同线程具有不同的数据副本的时候，就可以用到ThreadLocal

            ThreadLocal之所以有这么奇妙的效果，是因为不同线程访问同一个ThreadLcal的get方法，ThreadLocal内部
         会从各自的线程中取出一个数组，然后再从各自的数组中查找对应的值。

        消息队列的工作原理：
            1.MessageQueue主要包含两个操作：插入和读取。读取操作本身会伴随着删除操作，插入和读取对应的方法分别
         为enqueueMessage和next。其中EnqueueMessage的作用是往消息队列中插入一条消息，而next的作用是从消息队列
         中取出一条消息并将其从消息队列中移除。其内部是一个单链表，单链表在插入和删除上比较有优势。

         Looper的工作原理：
            Looper在android的消息机制中主要扮演着消息循环的角色，具体来说就是他会不停地从MessageQueue中查看是否
         有消息，如果有新消息就立即处理，否则一直阻塞在那里。


































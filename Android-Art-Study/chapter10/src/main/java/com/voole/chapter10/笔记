Android的消息机制

        Handler的使用过程很简单，通过它可以轻松的将一个任务切换到handler所在的线程中去执行。很多人认为handler的
        作用就是更新UI，这的确没错，但是更新UI只是handler的一个特殊的场景。

        MessageQueue虽然叫消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息队列。

        由于MessageQueue只是一个消息存储的单元，它不能去处理消息，而Looper就填补了这个功能，Looper会以无限循环
        的形式去查找是否有新的消息，如果有的话就处理消息，否则就一直等待着。

        Looper中还有一个重要的概念，那就是ThreadLocal，ThreadLocal并不是线程，他的作用是可以在每一个线程中
        存储数据，我们知道，Handler创建的时候会采用当前线程的looper来构造消息循环系统，那么handler内部如何获取
        到当前线程的Looper呢？这就要使用ThreadLocal了，ThreadLocal可以在不同的线程中互不干扰的存储并提供数据，
        通过ThreadLocal可以轻松的获取到每个线程的looper。当然需要注意的是，线程默认是没有looper的，如果需要使用handler
        ，就必须为线程创建looper。

        系统为什么不允许在子线程中访问UI呢？这是因为Android的UI控件不是线程安全的，如果多线程中并发访问可能会导致
        UI控件处于不可预期的状态。那为什么系统不对UI控件加上锁机制呢?缺点有两个：首先加上锁机制会让UI访问的逻辑
        变的复杂，其次加锁会降低UI访问的效率。

        注意looper是运行在handler所在的线程中的。这样一来，handler中的业务逻辑就被切换到创建handler所在的线程
        中去执行了。

        ThreadLocal的工作原理：
            ThreadLocal是一个线程内部的数据存储类，通过他可以在指定的线程中存储数据，数据存储后，只有在指定线程
         中获取到存储的数据，对于其他线程来说则无法获取到数据。
            一般来说，当某些数据是以线程为作用域，并且不同线程具有不同的数据副本的时候，就可以用到ThreadLocal
            




























